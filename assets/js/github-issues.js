---
  title: github - issues
---

/**
 * Gantt chart generated from GitHub Issues.
 *
 * Functions used to extract, transform and load GitHub Issues and generate an SVG Gantt Chart.
 */

/**
 * TODO:
 * - getMilestoneDates(qualifiedIssues)
 * - hasMilestoneStart(milestone)
 * - getMilestoneStart(milestone)
 * - filterMilestonesWithoutIssues() - TBC
 * - selectScope(startDate, endDate)
 * - toQuarters()
 * - toTimeFrame()
 * - refresh data from github api 
 * 
 * (Minimize refresh to manual or once an hour
 * This can be validated with Rate Limit status
 * and comparing remaining request
 * if (limit === remaining) {refresh_data})
 * https://docs.github.com/en/rest/reference/rate-limit#get-rate-limit-status-for-the-authenticated-user
 */
/*
const octokit = new Octokit();

let owner = "sara-sabr";
let repo = "ITStrategy"

octokit.request('GET /repos/{owner}/{repo}/issues', {
  owner: 'sara-sabr',
  repo: 'ITStrategy'
})

var issues = octokit;
*/


/**
 * Arrays of metadata (issues, labels) from GitHub
 */
var issues = {{ site.data.issues | jsonify }};
var labels = {{ site.data.labels | jsonify }};
var labelConvention = [":", "initiative"];

//console.log(issuesWithMilestones(issues));

console.log(issuesWithInitiative(issues, labels, labelConvention));


/**
 * Helper function listing the issue number of issues containing a milestone.
 * @param {Array} issues An array of issues generated from GitHub API.
 * @returns {Array} An array of strings containing issues number.
 */
function issuesWithMilestones(issues) {
  let issuesWithMilestones;
  let temp = issues
    .filter(issue => {
      return issue.milestone != null;
    })
    .map(issue => {
      return issue.number;
    });
  issuesWithMilestones = temp[0];
  return issuesWithMilestones;
}

/**
 * Helper function listing the issue number of issues containing at least one label.
 * @param {Array} issues An array of issues generated from GitHub API.
 * @returns {Array} An array of strings containing issues number.
 */
function issuesWithLabel(issues) {
  let issuesWithLabels = issues
    .filter(issue => {
      return issue.labels.length > 0;
    })
    .map(issue => {
      return issue.number;
    });
  return issuesWithLabels;
}

/**
 * Helper function listing the issue number of issues containing a milestone.
 * @param {Array} issues An array of issues generated from GitHub API.
 * @returns {Array} An array of strings containing issues number.
 */
function issuesWithoutMilestones(issues) {
  let issuesWithoutMilestones = issues
    .filter(issue => {
      return !issue.milestone == null;
    })
    .map(issue => {
      return issue.number;
    });
  return issuesWithoutMilestones;
}

/**
 * Helper function listing the issue number of issues containing at least one label.
 * @param {Array} issues An array of issues generated from GitHub API.
 * @returns {Array} An array of strings containing issues number.
 */
function issuesWithoutLabels(issues) {
  let issuesWithoutLabels = issues
    .filter(issue => {
      return issue.labels.length == 0;
    })
    .map(issue => {
      return issue.number;
    });
  return issuesWithoutLabels;
}

/**
 * Helper function validating if a label is an initiative by meeting a custom naming convention (initiative:<name>).
 * @param {Object} label An object containing the label metadata generated by GitHub.
 * @param {Object} labelConvention An object containing the separator and the naming convention for initiative labels.
 * @returns {boolean}
 */
function isInitiative(label, labelConvention) {
  return label.name.split(labelConvention[0], 1).toString() === labelConvention[1];
};

/**
 * Helper function parsing all issues to identify if they are assigned to a single initiative, unassigned or if there's an error to the custom logic.
 * @param {Array} issues An array of issues generated from GitHub API.
 * @param {Array} labels An array of labels generated from GitHub Api.
 * @param {Object} labelConvention An object containing the separator and the naming convention for initiative labels.
 * @returns {Object} An array of objects containing numbers for assigned, unassigned and errored issues.
 */
function issuesWithInitiative(issues, labels, labelConvention) {
  let issuesNumber = issuesWithLabel(issues);
  let initiativeLabels = labels
    .filter(label => {
      return isInitiative(label, labelConvention);
    })
    .map(label => {
      return label.name;
    });
  //console.log(initiativeLabels)
  let issuesWithInitiative = { "assigned": [], "unassigned": [], "error": [] };
  issuesNumber.forEach(issueNumber => {
    let issue = issueByNumber(issues, issueNumber);
    let initCount = 0;
    issue.labels.forEach(label => {
      (isInitiative(label, labelConvention)) ? initCount++ : initCount;
    });
    if (initCount == 1) {
      issuesWithInitiative.assigned.push(issueNumber);
    } else if (initCount == 0) {
      issuesWithInitiative.unassigned.push(issueNumber);
    } else {
      issuesWithInitiative.error.push(issueNumber);
    }
  });
  return issuesWithInitiative;
}

/**
 * Helper function to return a single issue by its number.
 * @param {Array} issues An array of issues generated from GitHub API.
 * @param {number} issueNumber The number of the issue to return.
 * @returns {Object} A GitHub issue object.
 */
function issueByNumber(issues, issueNumber) {
  let issueByNumber = issues.find(issue => {
    return issue.number === issueNumber;
  })
  return issueByNumber;
}

/**
 * Helper function returning all issues number based on a single initiative ID
 * @param {Array} issues 
 * @param {number} initiativeID
 * @returns {Array} New list of
 */
function issuesByInitiatives(issues, initiativeID) {
  let issuesByInitID = [];
  issues.forEach(issue => {
    const result = issue.label.find(label => {
      return label.id === initiativeID;
    });
    if (result != undefined){
      issuesByInitID.push(issueByNumber(issues, issue.number))
    }
  });
  return issuesByInitID;
}

/**
 * Helper function returning all initiatives and their issues.
 * @param {Array} issues An array of issues generated by GitHub API
 * @param {Array} labels An array of labels generated by GitHub API
 * @param {Object} labelConvention An object containing the separator and the naming convention for initiative labels.
 * @returns {Array} An array of objects.
 */
function getInitiatives(issues, labels, labelConvention) {
  let initiatives = [];
  let initiativesIDs = [];
  let issuesPerInitiatives = [];
  const issuesFiltered = issuesWithInitiative(issues, labels, labelConvention);
  //List all IDs for labels representing an initiative
  labels.forEach(label => {
    if (isInitiative(label)) {
      initiativesIDs.push(label.id: []);
    }
  });
  //List all issues associated with an initiative
  issuesFiltered.assigned.forEach(issue => {
    const initiative = issue.label.find()
  })
  initiativesIDs.forEach(init => {
  })
  issuesFiltered.forEach(issue => {

  })
  let thisIssue = issueByNumber(issues, issue);
  return initiatives;
}


var div = document.getElementById('svgContainer');
let issuesFiltered = issuesWithInitiative(issues, labels, labelConvention);
var header = document.createElement("h2");
var textNode = document.createTextNode("Issues associated to a milestone");
header.appendChild(textNode)
div.appendChild(header)
var h3 = document.createElement("h3");

var h3Text = document.createTextNode(issueByNumber(issues, issuesFiltered.assigned[0]).milestone.title)
h3.appendChild(h3Text);
div.appendChild(h3);
var para = document.createElement("p");
var paraText = document.createTextNode('Number of issues in milestone: ' + issuesFiltered.assigned.length);
para.appendChild(paraText);
div.appendChild(para);
issuesFiltered.assigned.forEach(issue => {
  var para = document.createElement("p");
  thisIssue = issueByNumber(issues, issue);
  var text = document.createTextNode(thisIssue.title);
  para.appendChild(text);
  div.appendChild(para);
});


//Need to validate how to handle when no unplanned issues
/*
function listIssuesWithoutMilestones(issues, milestones) {
  let unplannedIssues = issues.filter(issue => return !issue.hasOwnProperty("milestone"));
  return unplannedIssues;
}

const issuesSorted (issues, milestones) => {
  let issuesSorted = [];
  let todayDate = new Date();
}*/


//Temporary list of milestones and duration based on today
/*
function milestonesSorted(issues) {
  let issuesWithMilestones = listMilestonesFromIssues(issues);
  let todayDate = new Date();
  let milestonesList = [];
  let temp = []
  issuesWithMilestones.forEach(issue => {
    let duration = 0;
    let dueDate = new Date(issue.milestone.due_on);
    let title = issue.milestone.title;
    if (dueDate > todayDate) {
      duration = dueDate - todayDate;
    } else {
      duration = todayDate;
    }
    duration = duration / (4 * 7 * 24 * 60 * 60 * 1000);
    milestonesList.push([title, duration])
  })
  console.log(milestonesList);
  return milestonesList;
}

var data = milestonesSorted(issues);

var width = 600
scaleFactor = 20,
  barHeight = 30;

var graph = d3.select("#svgContainer")
  .append("svg")
  .attr("width", width)
  .attr("height", barHeight * data.length);

var bar = graph.selectAll("g")
  .data(data)
  .enter()
  .append("g")
  .attr("transform", function (d, i) {
    return "translate(0," + i * barHeight + ")";
  });
bar.append("rect").attr("width", function (d) {
  return d[1] * scaleFactor;
})

  .attr("height", barHeight - 1);

bar.append("text")
  .attr("x", function (d) { return (d[1] * scaleFactor); })
  .attr("y", barHeight / 2)
  .attr("dy", ".35em")
  .text(function (d) { return d[0]; });

/*

var svg = d3.select("#svg").append("svg").attr("viewBox", `0 0 300 600`)

for (let i = 0; i < 5; i++) {
  svg.append("rect").attr("x", 0).attr("y", i * 100).attr("width", 200).attr("height", 100).attr("fill", "white")
  svg.append("text").text(issues[i].title).attr("fill", "black")
}
*/
